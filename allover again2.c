העברת מערכים לתוך פונקציה : 

#include <stdio.h>
#define N 2
void setToTen(int a[N]){
    a[0] = 10;
    //שינוי תוכן בתוך פונקציה משנה את התוכן גם מחוץ לפונקציה
}
int main() {
    int x[N] = {2,2};
    setToTen(x);//קריאה לפונקציה: שם המערך ללא סוגריים
    printf("%d",x[0]);
    return 0;
}

דוגמוה 1 :
ממשו פונקציה 
int count_pairs(int arr[], int n , int k);
הפונקציה מקבלת מערך של שלמים את אורכו ומספר שלם והפונקציה מחזירה את מספר הזוגות הפסמוכים במערך 

int count_pairs(int arr[], int n , int k){
    int counter = 0; 
    for(int i = 1; i < n; i++){
        counter += arr[i -1] + arr[i] == k; // ??לא הבנתי מה  התנאי פה : ספור לי את האיבר הנוכחי פלוס האיבר במקום הקודם והאיבר במקום הנוכחי ותגרום לו להיות שווה לקיי?
    }
    return counter;
}


int main() {
    int n,k;
    if (scanf("%d",&n) !=1)// מה זו השורה הזו ? שורה לבדיקת תקינות קלט ?
         {
        return 1;
    }
    int arr[MAX_LEN];
    for(int i = 0; i < n; ++i){
        if (scanf("%d", &arr[i]) !=1){
            return 1; 
        }
    }
    if(scanf("%d",&k) != 1){
     return 1;   
    }
    printf("%d", count_pairs(arr,n,k));
    return 0;
}

לא הבנתי את האלגוריתם לא אוכל להצליח לממש אותו לבד  שוב גם ככה גם כאלה שאני כן מבינה אני לא מצליחה ..




  תרגיל 2 :
#include <stdio.h>
#define N 128 

//פונקציה מקבלת תווין בגודל אן ומספר קיי כלשהו מדפיסה כמה תווים מופיעים במערך בדיוק קיי פעמים


int count_freq_k(char arr[], int n, int k){
    int hist[N] = {0};
    for(int i = 0; i < n; i++){
        hist[arr[i]]++;
    }
    int count = 0;
    for (int i = 0; i <N; i++){
        counter += (hist[i] == k);//עוד פע םאותו טריק תנאי שאני מבינה מה בתאוריה התכוונו אולי אבל לא בטוחה בעצמי ובטח שלא אדע לרשום אותו בעצמי 
    }
    return counter;
}


דוגמה שלוש : 
כתבו פונקציה בהנתן מספר שלם נגדיר את סכום הספרות הסופי כערך המתקבל מחישוב סכום הספרות של המספר ואז חישוב סכום הספרות של ערך זה וכו.....עד להגעה למספר חד ספרתי 
  4375 :
  19=4+3+7+5
  10=1+9
  1=1+0

 
  פתרון שאני לא הכרתי או חשבתי עליו בעצמי : 
  
int digit_rec_sum(int num){
  return 1 + ((num-1)%9);
}
נמאס לי לכתוב שאני לא מבינה אז אני ארשום שמרגע זה אני כנראה אף תרגיל מהעתיד לא מבינה אלא אם במפורשות כתבתי אחרת 


תרגיל 4: 
  ממשו פונקציה אשר תקבל כפרמטר מערך של מספרים ממשיים ואת אורכו ותחזיר את המספר השני הקטן ביותר במערך זה. 
  מובטח שבקלט יופיעו לפחות שני ערכים שונים.

  double second_smallest(double arr[], int n){
double min_val = arr[0];
for (int i = 0; i < n; i++){
if(arr[i] < min_val){
min_val = arr[i];
}
}
double second_min_val = arr[0];
for (int i = 0; i <n ;i++){
if(min_val == second_min_val || (arr[i] < second_min_val && min_val < arr[i])){
second_min_val = arr[i];
}
}
return second_min_val;
}


תרגיל 5 : 

  בהנתן מערך : 
  arr 
של מערכים ממשיים ואינדקס כלשהו 
i 
במערך , נגדיר את ערך ההחלקה הממושקלת שלו באינדקס הנתון לפי ערך החישוב הבא : 
0.1*arr[i-2]+0.2*arr[i-1]+0.4*arr[i] +0.2*arr[i+1]+0.1*arr[i+2]
  כאשר אנו מתייחסים לערכים הנמצאים מחוץ לגבולות המערך כבעלי הערך 0.0

  ממשו את הפנוקציה שחתימתה : 
  double weighted_mean(double arr[],int n,int idx);
אשר תקבל כפרמטר מערך של מספריים ממשים או אורכו 
ואינדקס כלשהו במערך ותחזיר את ערך ההחלקה הממושקלת של המערך באינדקס זה 
, ניתן להניח שהקלט תקין שהמערך לא ריק ושהאינדקס הוא בגבולות המערך 


מימוש: 

 double midterm_q3(double arr[],int n,int idx) {
     double sum = 0.0; //התחלתי משתנה של סכום
     if (idx - 2 >= 0)
         //אם האינדקס שלי פחות 2 גדול או שווה לאפס
     {
         sum += 0.1*arr[idx -2];
     }
     if(idx -1 >= 0){
         sum += 0.2*arr[idx -1];
     }
     sum+= 0.4*arr[idx];
     if(idx +1 <n){
         sum +=0.2*arr[idx +1];
     }
     if(idx +2 <n){
         sum += 0.1*arr[idx+2];
     }
     return sum;
}

הפונקציה : 
float

float delta_age;
floatdelta_height;
float age1 =2 , age2 =3, height=1.67 , height2 = 1.78;
delta_age = delta(age1,age2);
delta_height = delta(height1,height2);


הסתרה של משתנים - משתנה בבלוק פנימי מסתיר משתנה מבלוק חיצוני אם הם בעלי אותו השם הסתרה לא תלויה ביטפוס , רק בשם .

  עכשיו מדברים על מחסנית הקריאות וסוגי משתנים אני לא חושבת שיש פה משהו שלא הבנתי יש דברים שלא אזכור כנראה אם אצטרך להשתמש נגיד בסינטאקס להצבת משתנים גלובלים סטיים או כואבל אני עושה הכי טוב שאני יכולה 





  שיעור 6 : מצביעים :) 

מתוך הרצאה : 
העברת פרמטרים לפונקציה by value 

void swap(intx , int y ) {
  int temp = x; 
x=y;
y=temp;
}
int main(void)
{
  int x=5,y=7
swap(x,y)


העברת מערך לתוך פונקציה: 
מערך לא עובר
by val
לפונקציה 


#include <stdio.h>
#define NUM 10
void ArrayRead(double a[],int);
double ArraySum(double [],int);
int main(void) {
    double slries[NUM];
    ArrayRead(slries, NUM);
    double avrg = (double) ArraySum(slries, NUM) / NUM;
    .....
}
void ArrayRead(double a[],int len){
    for(int i = 0; i < len; ++i){
        if(scanf("%if",&a[i])<1){
            exit(1);
        }
    }
}

הוצאת מקבץ ערכים מפונקציה :

לשים לב לא ניתן להעביר פקודת! 
return
  לקבוצת משתנים או למערך (זה אחת הטעויות שעשיתי בתרגיל שניסתי לפתור )

א

מגבלות שיש לפנוקציות : 
  1. חוסר יכולת של פונקציה לשנות משתנםים המועברים אליה 
  חוסר יכולת להעתיק מערכים לתוך הפונקציה 
  חוסר יכולת לקבל פונקציה תואה שאינה סקלרית ?
  פתרון : 
  שימוש בכתובתו של משתנים כתחליף לשימוש ישר בהם 


  דוגמאות להכרזות על מצבעים :
  1. 
  int a;
  int *p;
p=&a;

2. 
  double *dp,*dq;
char c ;
char *cp1,*cp2 = &c;
double x:
dp=dq=&x;

אסור ! 
  לערבב סוגי טיפוסים :
  int *p;
double a;
p = &a 
לא חוקי!! 

  שימימ לב משהו שעשית ! : 
  מותר ! לעשות המרה אבל זה נחשב מהלך מסריח \ מסוכן עדיף שלא .. 
  איך תראה המרה ? :
  p=(int*)&a;


מימוש פונקציית 
swap 
שמעבירה כתובתו של משתנים לפונקציות 


void swap(int*x,int*y){
  inttemp =*x;
*x =*y;
*y = temp;}


תרגיל 1: 
  פונקציה שמצמצמת שבר : 
  הפונקציה מקבלת 2 משתנים 
  a,b 
  אחד המונה והשני הוא המכנה של השבר והפונקציה תחזיר את השבר המצומצם

  
int gcd(int m,int n); // מה זה gcd ? לא הסדר של מה שכתבנו ?
void reduce(int*p_numerator,int *p_denominator){
    int g = gcd(*p_numerator,*p_denominator);// מה הפונקציה עושה פה? בימין 
    *p_numerator /=g;
    *p_denominator  /=g;
    return;
}


זה נראה לי כמו תרגיל שאמור להיות קל ורק נועד לעזור להתמיע את ההבנה יותר אז אולי לנסות לעשות אותו שוב למרות שלא הבנתי עד הסוף את האלגוריתם יכול לעזור להמשך ..


תרגיל נוסף : 
פונקציה שמחברת שני שברים :


/*
 * נרשום פונקציה שמחברת שני שברים  המונה הוא m
 * המכנה הוא n
 *n/m= n1/m1+n2/m2
 * 
 * בפתרון הם משתמשים בפונקציה לשמדנו כבר שעושה משהו שאנ ילכאורה אמורה לזכור אבל אני לא זכרתי שזה מה שהפונקציה הזו עושה 
 * gcd(m,n)= m*n ?
 */

//מימוש:

int gcd(int,int);
void reduce(int *x,int*y);
int lcm(int m,int n); // least common multiplier- מה זה אומר לי שזה פונקציה יגדוע שמחשבת את מה שאני רוצה ?

void add(int *pa,int *pb,int a1,int b1,int a2,int b2)
{
    *pb = lcm(b1,b2)+a2*(*pb/b2);
    reduce(pa,pb);
}
int lcm(int m, int n){
    return m /gcd(m,n)*n;
}

אני  יכולה להסתכל על התרגולים וההרצאות שוב עוד מליון שנה ואני עדיין לא אבין כלום כאגיע לשלב שהם מראים פתרונות ומימושים 
אני מקרה אבוד :) 
אבל לפחות אני עקשנית:)

הקבוע NULL
  סינטאקס : 
  int *p = NULL //זה אומר לי שכרגע המשתנה שלי לא מכיל כתובת :)


תירגול 6 : 
  הסטוגרמות ומערכים דו מימדיים , שאלות חזרה 


היסטוגרמה : 
  בהנתן תחום בדיד (שאפשר לספור) היסטוגרמה אומרת כמה יש מכל סוג. 
  ניתן ליצג אותה בתורמערך שכל מקום בו מציג ערך בתחום ומה שיש בפועל בפנים מייצג את מספר הפעים שהופיע


  לשים לב לפעמים מבקשים במפורשות לבנות היסטוגרמה אבל אומרים זאת במסווה 

  דוגמה לבניית היסטוגרמה :
  int main(void){
int hist[n] = {0};
int grade; 
while (scanf("%d",grade) ==1){
hist[grade]++;
}
}

תרגיל 1 : 
  הגדרה : מספר מסודר הוא מספר שבו כל ספרה מופיע בדיוק מפסר פעמים השווה לספרה עצמה או שלא מופיע בכלל.
  למשל : 344232344

  כתבו פונקציה שמקבלת מספר חיובי ומחזירה ערך אמת אם הוא מסודר וערך שקר אם הוא לא . על הפונקציה לשתמש לכל היותר ב8 משתנים:

  
#define N 10
bool is_organized(int num){
    int hist[N] = {0};
    while (num > 0){
        int digit = num % 10;
        hist[digit]++;
        num /= 10;
    }
    for(int i = 0; i< N; i++){
        if(hist[i] !=i && hist[i] != 0){
            return false;
        } 
    }
    return true;
}


פתרון משופר : 

void get_hist(int num, int hist[N]);
bool check_hist(int hist[N]);
#define N 10
bool is_organized(int n){
    int hist[N] = {0};
    get_hist(n , hist);
    return check_hist(hist);
}

יש עוד 2 פתרונות משופרים אם את רוצה לראות אותם להכיל אותם כנסי שוב לשיעור 6 


  תרגיל2 :
 
gradesלכתוב פונקציה שמקבלת ציונים במערך****
  sorted וממיינת אותו לתוך מערך 

מימוש : 

מבנה כללי 

#define N 1101
void sort(int grades[N],int sorted[N]){
    int hist[???]=???;
    //build hist ?? מה זה אומר
    for(int i = 0; i < N; i++){
        ???;
        
    }
    //fill sorted[]??????
    for(int i = 0; i <= ???;i++){
        ????
    }
}



          ובדוגמה הספציפית שלנו של חישוב ציונים: 
          

#define MAX_GRADE 100
void sort(int grades[N], int sorted[N]){
    int hist[MAX_GRADE+1] = {0};
    for(int i =0; i<N;i++){
        hist[grades[i]]++;
    }
    int cur_index = 0;
    for(int i = 0; i <= MAX_GRADE; i++){
        for(int j = 0; j <hist[i]; j++){
            sorted[cur_index++] = i;
        }
    }
}


תרגיל ב2: 
  ממשו פונקציה שמקבלת כקלט את רשימת ציוני הסטודנטים ומחזירה את החציון  *****.
  int get_median(int grades[N]){
int sorted[N] = {0};
sort(grades,sorted);
return sorted[N/2];
}


מערכים דו מימדיים : 
double matrix[N][M]
נוח לחשוב ע למערך דו מיימדי כמטריצה ששוותיה מסומנים 
N 
והעמודות מסומנות ב
M


תרגיל1  : 
כתבו תכנית שמקבלת מהמשתמש 10 נקודות במרחב ומחשבת את מרכז המסה שלהן 

  זהו תרגיל של 3 עמודים וגם התרגיל השני של המטריצות לכן ברשותי אני אדלג עליהם היום כי יש עוד מלא חומר וכבר 4 לפנות בוקר ולא נגעתי באינפי לא נגעתי במתקא 






  שאלות חזרה לבוחן אמצע שהיה 
  מתרגול מספר 6 : 
  
  ממשו פונציה שמקבלת מערך באורך 1.
  n
המתארת את השינוי במחיר המניה לאורך זמן , ומחזירה את הרווח המקסימלי שניתן להרוויח על ידי פעולת הקניה ומכירה של מניה אחת . 

2. כתבו תוכנתי שמקבלת כקלט מספר 
  K
  ורשימה של 10 מספרים נוספים ומדפיסהשני מספרים שונים מהרשימה שסכומם הוא 
  K 
  במידה וקיימים , אחרת מדפיסה כי לא קיימים מספרים כאלה . 

  אוקי יש עוד איזה 3 או 4 שאלות חזרה 
  אני לא אנסה אותם עכשיו גם ככה חומר שלא במבחן שהם רק נותנים כדוגמאות אני לא מצליחה להבין אז את זזה על אחת כמה וכמה 



  אריתמטיקה של מצבעים והקצאות דינאמיות : 
  יש פה רק קישור להרצאה: 

  אריתמטיקה של מצביעים אני חושבת שאני זוכרת וגם מבינה :) 


  
  מערכים ומצביעים: 
	ב -C שמו של המערך משרת ככתובת האיבר הראשון של המערך 
	(מצביע לאיברו הראשון(

	מכאן שאנחנו יכולים להפיעיל עליו אריתמטיקה של מצבעים זה יראה כך : 

	&salaries[0] <----> saleries + 0
	&salaries[1] <----> saleries + 1
	&salaries[2] <----> saleries + 2
  .
	.
	.
  &salaries[i] <----> saleries + i

	כיצד ניגש לאיבר ה
i 
	בעזרת מצביעים ?
	תשובה :
	*(saleries +i)


	הדוגמה שנתנו בעמוד 13 לטענה שנתנו לא היתה י מובנת ..


עוד בסינטאקס לא שאני אזכור אבל יאללה : 
	sizeof הפעלת
	במערך - מספר הבתים שתופס כל מערך 
	במצביע מספר הבתים שתופס משתנה מסוג מצביע 

שם של ממערך וא קבוע לא ניתן לשנות את הכתובת אליה הוא מצביע 


העברת מערכים כפרמטרים לפונקציה : 
	איך מעבירים מערך לפונקציה ? 

	הפונקציה מקבלת מצביע שניתן דרכו לגשת לכל איברי המערך : 
	סינטאקס : 
	void read_arr(double a[],int n);
	or 
	void read_arr(double *a, int n);
	שקולים 

	יש פה דוגמה למימוש בלי להגידמה רוצים לממש אני צריכה לראות את זה שוב בקול כדי לדעת מה היתה פה הדוגמה .. עמוד 16 

	הקצאות דינאמיות : 
	פונקציית הסיפריה 
	malloc()
	stdlid.h

	סינטאקס :

	double *p;
	int n;
	p = (double*) malloc(n*sizeof(double));
	if (p == NULL) {
	return 1;
	}

	שחרור זכרון : באמצעות הפונקציה 
	free 
	לשחרר מוקדם ככל האפשר אבל לא לפני שהשתמשת בזכרון שרצית .. 
ומשחררים פרמטרים בלבד ?

	תרגול 7 חיפוש בינארי + 
	שאלות ממבחנים : 

	הקוד של האלגוריתם : 
	int binarySearch(int a[], int n , int x){
	int low =0 , mid, high = n-1;
	while (low <= high){
	mid= (low + high)/2;
	if (x < a[mid]){
	high = mid -1;
	}
	else if (x>a[mid]){
	low = mid +1;
	}else {
	return mid;
	}
	}return -1; //האמת שנראלי שמובן לי האלגוריתם הזה רק לא מובן למה -1 בסוף 
	
	}

	ניתוח האלגוריתם : 
	סיבוכיות : 
	[log (bis2)  n ]+1
	לא שאני מבינה איך הגענו ללוג אבל בגיד שאויל אפ אעבור על מתמטיקה של תיכון אז משהו יסתדר בראש


תרגילים שנתנו בשיעור \תרגול 7 על חיפוש בינארי: 
1. חימומון: 

	מערך 
	a 
	בגודל 
	n 
	יקרא מערך עולה יורד אם קיים 
	i
	עבורו :
	a[0], a[1],a[2]... a[i] 
	ממויינים בסדר יורד 
	ו- 
	a[i],a[i+1]....a[n-1]
	ממויינים בסדר עולה 
	כתבו פונקציה שמקבלת מערך יורד עולה בו כל האיברים שונים זה מזה ואת גודלו ומחזירה את המיקוןם של האיבר המינימלי בו 


	מימוש : 

	
int find_min(int a[], int n){
    int l = 0 , r = n - 1;
    while (1 <= r){
        int m = (1 + r) / 2;
        if(m == 0){
            return (l==r || a[0] < a[1]) ? 0 : 1;
        }
        if(m == n-1){
            return m;
        }
        if(a[m-1] > a[m] && a[m] < a[m+1]){
            return m;
        }
        if (a[m-1] > a[m]) {
            l = m+1;
        }else{
            r = m-1;
        }
    }return -1; 
}

לא הבנתי כלום אבל מה חדש וזה עוד היה חימום :)


בלה בלה ..


תרגיל 1: 
	יש לנו שני מערכים ממויינים שהאיברים שלהם זהים למעט שבמערך אחד יש איבר אחד יותר מבמערך השני כלומר המערך השני מוכל במערך הראשון :)
	צריך לכתוב פונקציה שמקבלת את המערכים אללו ומוצאת מיהו האיבר שחסר באחת הקבוצות 

	פתרון 1 :
	
int find_missing_sorted(int a[],int b[],int n){
    int l = 0 , r = n;
    while (l < r) {
        int m = (l + r) / 2;
        if(a[m] == b[m]){
            l = m + 1;
        }else {
            r = m;
        }
        
    }
    return b[l];
}

	חיפוש בינראלי תרגיל 2 : 
	נתון : מערך שאם נתבונן על המקומות הזוגיים בלבד נקבל מערך ממויין בסדר עולה וכנ"ל לדבי המקומות האי זוגיים

	צ"ל: פונקציה המקבלת מספר שלם 
	X
	ומערך ממוין לסירוגין של מספרים שלמים 
	A 
	ן
	ואת גודל המערך 
	הפונקציה מחזירה מספר שלם 
	M
	אנחנו רוצים בחיפוש הבינארי למצוא את X 
	X מוגדר להיות סכום של שני איברים סמוכים במערך 
	ואפונקציה מחיזרה לי את האינדקס של המספר הראשון מביניהם 
	אם לא קיים מספר כזה הפונקציה תחזיר לי -1 

	מימוש: 
	int find_x(int a[], int n, int x){
    int l = 0, r = n-2,m,sum;
    while (l <= r){
        m = (l + r) / 2;
        sum = a[m] +a[m+1];
        if(sum ==x){
            return m;
        }
        if (sum < x){
            1 = m + 1;
        }else {
            r = m - 1;
        }
    }
    return -1;
}



	***TUTORIAL 7 
	BINARY SEARCH :
	עמוד 17 תרגילים ממבחנים 
	עדיין לא ברמה אין לך למה להסתכל ...



	שיעור 8\ תרגול 8 
	מחרוזות שיטות מיון איטרטיביות 

	מחרוזות ושיטות מיון - מתוך הרצאה 8:
דגשים כללים: 
-	מחרוזת היא קצת כמו מערך 
-	הסוג הוא char 
Char   = 1 bit- 
-	כל מחרוזת נגמרת בתו המיוחד '0\'
-	שם המערך S משמש כמצביע לתחילת המחרוזת
-	גישה לאיברי המחרוזת היא באמצעות * או []
-	דוגמאות ל3 דרכים לספור את כמות הרווחים שיש במחרוזת :

//1.
i = 0; 
counter = 0;
while (s[i]) {
    if(s[i++]==' '){
        ++counter;
    }
}

//2. 
while (*p){
    if(*(P++) == ' '){
        ++counter;
    }
}

//3. 
i = 0;
counter = 0;
while (*(s+i)){
    if(*(s+i++) == ' '){
        ++counter;
    }
}
לשים <3 ! אם המצביע מסוג מערך אסור לקדם את המצביע עצמו במקרה הזה ! 
-	עבודה עם מחרוזות יכולה להיות יותר קלה אם נעזרים בספריה string.h 
 לשים <3 ! במבחן לא נוכל להשתמש בפונקציות המוכרות של הספריה נצטרך לדעת לממש אותם לבד !  קיימות לנו 4 כאלו : strlen(s), strcpy(d,s),strcat(d,s),strcmp(s1,s2)
-	לצורך קליטת מחרוזות והדפסתן יש להשתמש בהנחייה %s
-	//פונקציה המקבלת מחרוזת המייצגת מספר שלם ומחזיררה את המספר זהה כלומר עבור 354 היא לחזיר 354 . 
int str2int(char*str){
    int num = 0;
    while(*str){
        num = num * 10 + (*str -'0');
        str++;
    }
    return num;
}

שאלה מורכבת : 
נגדיר משקל של אות בא"בהאנגלתי כמספרה הסידורי של האות בא"ב 
נגדיר משקל של מילה כסכום המשקלות של אותיותיה
א.	כתבו פונקציה המקבלת מילה כמחרוזת ומחזירה את משקלה. הניחו שהמילה לא ריקה ומכילה אותיות אנגליות קטנות בלבד. 
ב.	כתבו פונקציה המקבלת מערך של מחרוזות ואת אורכו ומחזירה מצביע למילה שמשקלה הוא המרבי. הניחו שהמערך לא ריק וכל המילים בו אינן ריקות ומכילות אותיות אנגליות קטנות בלבד.
ג.	//ex_A1:
int  calc_weight(char*s){
    int weight = 0;
    while (*s){
        weight += (*s - 'a' + 1);
        s++;
    }
    return weight;
}
//ex_A2:
int calc_weight(char*s);
char*find_max_weight(char*s[], int n){
    int max_idx = 0;
    int max_weight = calc_weight(s[0]);
    for(int i = 1; i < n; i++){
        int weight = calc_weight(s[i]);
        if (weight > max_weight){
            max_idx = i;
            max_weight = weight;
        }
    }
    return s[max_idx];
}

-	שאלה ממבחן : 
נתונות 3 מחרוזות המורכבות מאותיוות קטנות באנגלית שיכולות לקחת משתנים רק מהאות הראשוה הקטנה באנגלית עד לאחרונה. 
כתבו פונקציה שמדפיסה רשימה של אותיות המופיעו גם במחרוזת 1 וגם במחרוזת 2 אבל לא במחרוזת שלוש . הדפיסו כל אות כזו פעם אחת בלבד בסדר עולה מהאות הקטנה ביותר לאות הגדולה ביותר.
פתרו את הבעיה ללא לולאות מקוננות כלומר במעבר יחיד על המחרוזת .
//ex_B 

#define ABC 26
void print_letters(char s1[], char s2[] , char s3[]){
    int hist1[ABC] = {0};
    int hist2[ABC] = {0};
    int hist3[ABC] = {0};
    update_hist(s1, hist1);//האם זאת מילה שמורה בספריה של מחרוזות ? אם כן האם מותר לנו להשתמש בה במבחן ?
    update_hist(s2, hist2);
    update_hist(s3, hist3);
    for(int i = 0; i <ABC; i++){
        if(hist1[i] && hist2[i] && !hist3[i]){
            printf("%c", i +'a');
        }
    }
}
// כיצד היה ניתן לפתור עם היסטוגרמה אחת בלבד ?

void update_hist(char*s , int hist[]){
    while(*s){
        hist[*s-'a'] = 1;
        s++;
    }
}














נושא הבא :
מיונים 😊 
אלגוריתמי מיון ידועים שצריך לדעת לנתח את מורכבותם החישובית : 

1.MAX SORT
- יבצע n-1    איטרציות.
מימוש: 

//find the idx of the maxinal element//
 int index_of_max(int a[],int n){
    int i , i_max = 0;
    for(i = 1; i < n; ++i){
        if(a[i] > a[i_max]){
            i_max = i;
        }
    }
    return i_max;
}

//דרך 1 לכתוב את החלק הבא של המערך :
void max_sort(int a[],int n){
    int length;
    for (length = n; length > 1; --length) {
        int i_max = index_of_max(a,length);
        swap(&a[length-1],&a[i_max]);//האם SWAP היא מילה שמורה ?
    }
}
//דרך שניה לכתוב זאת
void max_sort(int a[], int n)
{
    for(int length = n;length > 1; --length){
        swap(&a[length-1],&a[index_of_max(a,length)]);
    }
} 
 



מיון מפורסם שני: 
מיון הבועות BUBBLE -SORT
-	סיבוכיות ?
-	//bubble sort

int bubble(int a[], int n){
    int swapped = 0;
    for(int i = 1; i < n; ++i ){
        if(a[i-1]>a[i]){
            swap(&a[i],&a[i-1]);
            swapped =1;
        }
    }
    return swapped;
}
void bubble_sort(int a[],int n){
    while(bubble(a,n--));
    /*empty*/
}

השוואות בין מיונים 😊 
יעילות : 
2 האלגוריתמים לא מאוד יעילים 
באלגוריתם הבועות תוצאות חלקיות יותר טובות משל אלגוריתמי מיון אחרים( בשל בסידורים החלקיים המושגים תוך כדי ריצה )
בואו נדבר על סיבוכיות : הוא מדבר פה על הסיבוכיות של 2 הפונקציות 
טטהבסוגרים אן בריבוע . צריך להבין יורת תעומק את כל עניין  הסיבוכיות . ! 









הרצאה 8 עמוד 40 יש שאלה ממבחן בנושא מיונים : אני לא ברמה של שאלות מבחן משאירה אותה להמשך 😊 
מיזוג בין ערכים ממויינים  :MERGING 
הקלט : אורך 1 אורך 2 מערך 1 מערך 2 
פלט רצוי :  מערך 3 איחוד מערך 1 – 2 
void merge(int a[], int na,int b[],int nb,int c){
    int ia,ib,ic;
    for(ia=ib=ic=0;(ia<na)&&(ib<nb); ic++){
        ia = ib = ic =0;
        while (ia < na && ib < nb){
            c[ic++] = (a[ia] < b[ib]) ? a[ia++] : b[ib++];
        }
        for(;ia <na; ia++,ic++){
            c[ic] = a[ia];
        }
        for(;ib<nb;ib++,ic++){
            c[ic] = b[ib];
        }
    }
}
 לא בטוחה בזה שזה המימוש לבדוק לפני שימוש או חזרה 😊 

סיבוכיות של מיזוג :  ? 












מיון באמצעות מיזוג :MERGE-SORT
-	לבדוק הסבר על סיבוכיות שוב 😊
-	לא קיים אלגוריתם מיון מבוסס השואות בעל סיבוכיות זמן קטנה יותר. 
-	במימוש האלגוריתם נעשה שימוש בספריות memcpy , string.h 
כדי להעתיק נתח זיכרון במיקום ואורך ידועים. 
int merge_sort(int ar[],int n)
{
   int len;
   int *temp_array,*base;
   temp_array= (int*)malloc(sizeof(int) *n);
   if(temp_array == NULL){
       printf("arror");
       return FAILURE;
   }
   for (len =1; len <n ; len *= 2){
       for(base= ar;base<ar+n;base +=2*len){
           merge(base,len,base+ len,len,temp_array);
           memcpy(base,temp_array,2*len*sizeof(int));
       }
   }
   free(temp_array);
    return SUCCESS;
}




